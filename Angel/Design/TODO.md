## Quick todo 

Rename Tuple to VariableS (now that it's free? Or too similar. Need Tuple for something else? 

## Backlog 
- [*] Get back up 
-    [*] remove wstring and platform dependenty conversion 
-    [*] move, build
-    [*] Fix logic unit tests
-    [*] Recursively match and infer clauses, can't return a disjunction of all matched predicates. they won't have the same scope
-    [*] Clear distinction between language casts and operators (equal) and C++ operators/bool? Perhaps equal is the same (same type & value) but Cast is not implicit unless infering/matching
-    [*] Redesign polymorphic Expression with std::variant ? (expessions would get big? or op + vector)
-    [x] Refactor Object away (renamed to expression)
- [*] Redesign the parser 
-   [*] Knowledge is a set of clauses, clauses are pairs predicate: expression
-   [x] Disjunction and Conjunction are examples of NAry-operators (are they also expressions?)
-   [x] Sequences and sets perhaps as well (collections) with the , operator 
-   [*] Define constexpr context free grammar
-   [*] Recursive descent parser  
-   [*] Find a way for the production rules to produce
-   [*] Check the grammar for constraints of LL(1): left recursion 
in sequence instead of in tr)
-   [*] Parsing enough for axioms
-   [*] Parsing enough for clauses
-   [*] Parsing enough for predicates with arguments
-   [*] Parse set of axioms
-   [*] Parse variables 
-   [*] Parse conjunctions 
- [ ] Prolog 
-   [*] query horn clause 
-   [*] Query predicate  
-   [*] Variable clauses with substitution 
-   [*] Query with variable and return hypotheses
-   [*] Sequences for valence 2+ predicates
-   [*] Disjunctions
-   [*] Negation  
- [ ] Console and built in commands useful for debugging
-   [*] help 
-   [*] help($topic)
-   [*] delete clauses (lock knowledge? Special Functions with write access?)
-   [ ] print  
-   [ ] trace 
-   [ ] break ? 
- [ ] Functional 
-   [*] define constants 
-   [ ] define (non boolean) functions 
-   [ ] query functions
-   [ ] integer operators `+-*/^` 
-   [*] lists
-   [ ] sets to the same level as lists (equality, var&tuple matching, operator. etc)
-   [ ] set and list operators `&|+-` (if both side containers?) 
-   [ ] Be able to implement factorial like Haskell https://en.wikipedia.org/wiki/Haskell#Code_examples
-   [ ] Be able to implement quicksort like Hashell https://en.wikipedia.org/wiki/Haskell#Code_examples (x:xs means [x]+xs if xs is a list or as used here to split head:tail
-   [*] Membership operator x.{x,y} (done for List)
- Python
-   [ ] namespaces
-   [ ] Indexing lists (not sets, only)  [x,y,z][1]
-   [ ] Add floating points and conversions
-   [ ] ranges [x..y] 
-   [ ] infinite ranges [..y]
-   [ ] More advanced ranges, with step ?  (syntax?) x..y*3 is step 3 but to from x*3 to y*3 ? 
-   [ ] Even more advanced with functional filter, eg even or fibonachi 
-   [ ] range slicing
-   [ ] For each operator *x..y
-   [ ] Assigning a free clause association is a lambda `l: sqr(n):n*n`.   
-   [*] Make knowledge and namespace expressions, clauses associations 
-   [ ] Sub namespaces
-   [ ] Figure out numpy like stuff. Is using @ * to multiply or fn() all items in a container sufficient?  
-   [ ] Multi dimensional arrays (as a separate collection type)?
-   [ ] Apply functions on sequences, sets and arrays with for each 
- [ ] Advanced
-   [ ] Tautology protection cat: cat (or longer) is an error
-   [ ] Prefix comparators for matching. 
-   [ ] For any operator `@` while infering 
-   [ ] For any & each operators also while matching (each sort of done with Tuple I guess)
-   [ ] Other MFINAE type matching or even some concept like syntax 
-   [ ] free pairs `a:b` 
-   [ ] Derive Clause from Pair or make an isClause() helper?
-   [ ] Lambdas are free clauses
-   [ ] Namespace from `axiom:{set,}` preferably without the comma when parsing. Are commas ever needed for collections? for arguments?
-   [ ] dicts (sets of associations) work as structs
-   [ ] set access with `.` (list done, full feature for unique) 
-   [ ] Bag as unordered list if it has any advantages for speed and such 
-   [ ] Optimization: Reduce copies when matching and inferring and add references to known knowledge 
-   [ ] Optimization: Also pass references to ranges, eg when slicing lists, matching with Tuple etc until a copy is necessary. 
- [ ] Native functions
-    [ ] Add native cast functions (id, int, float, str, list, set, dict)
-    [ ] Add native collections functions (size, empty, ordered, unique)
-    [ ] Add native collection casts
-    [ ] file IO
-    [ ] UI / stdin/out IO 
- [ ] LL Parser
-   [ ] Unit tests for simple grammars to create first/follow table
-   [ ] Implement LL(1) https://www.geeksforgeeks.org/types-of-parsers-in-compiler-design/
-   [ ] Consider LL(n)
-   [*] Clean up old parser 
-   [ ] Optional: extend BNF with elipsis `...` (also in its own) that repeats a rules terms until failure (and generates each - [ ] Custom functions
-    [ ] Import of custom native functions (eg math)
-    [ ] string functions 
-    [ ] file functions 
-    [ ] json parsing & dumping 

