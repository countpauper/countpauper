- [ ] Get back up 
-    [x] remove wstring and platform dependenty conversion 
-    [x] move, build
-    [x] Fix logic unit tests
-    [x] Recursively match and infer clauses, can't return a disjunction of all matched predicates. they won't have the same scope
-    [x] Clear distinction between language casts and operators (equal) and C++ operators/bool? Perhaps equal is the same (same type & value) but Cast is not implicit unless infering/matching
-    [ ] Redesign polymorphic Expression with std::variant ? (expessions would get big? or op + vector)
-    [ ] Refactor Object away 
- [ ] Redesign the parser 
-   [ ] Knowledge is a set of clauses, clauses are pairs predicate: expression
-   [ ] Disjunction and Conjunction are examples of NAry-operators (are they also expressions?)
-   [ ] Sequences and sets perhaps as well (collections) with the , operator 
-   [x] Define constexpr context free grammar
-   [x] Recursive descent parser  
-   [x] Find a way for the production rules to produce
-   [x] Check the grammar for constraints of LL(1): left recursion 
-   [ ] Unit tests for simple grammars to create first/follow table
-   [ ] Implement LL(1) https://www.geeksforgeeks.org/types-of-parsers-in-compiler-design/
-   [ ] Consider LL(n)
-   [x] Clean up old parser 
-   [ ] Optional: extend BNF with elipsis `...` (also in its own) that repeats a rules terms until failure (and generates each in sequence instead of in tr)
-   [x] Parsing enough for axioms
-   [ ] Parsing enough for clauses
-   [ ] Parsing enough for predicates
-   [ ] Parse variables 
- [ ] Prolog 
-   [ ] query horn clause 
-   [ ] Query predicate  
-   [ ] Variable clauses with substitution 
-   [ ] Query with variable and return hypotheses
-   [ ] Sequences for valence 2+ predicates 
-   [ ] Tautology protection cat: cat (or longer) is an error 
- [ ] Functional 
-   [ ] define constants 
-   [ ] define lambdas 
-   [ ] integer operators `+-*/^` 
-   [ ] query lambda
-   [ ] lists 
-   [ ] sets 
-   [ ] set and list operators `&|+`
-   [ ] Membership operator x @ {x,y}
- Python
-   [ ] namespaces
-   [ ] Indexing sequences (not sets)  [x,y,z][1]
-   [ ] ranges [x:y] 
-   [ ] infinite ranges [:y]
-   [ ] range slicing
-   [ ] For each operator *[x,y]
-   [ ] Make knowledge and namespace expressions, clauses associations 
-   [ ] Sub namespaces
-   [ ] Figure out numpy like stuff. 
-   [ ] Multi dimensional arrays (as a separate collection type)?
-   [ ] More advanced ranges, with step ?  
-   [ ] Apply functions on sequences, sets and arrays with for each 
- [ ] Advanced
-   [ ] Add floating points and conversions
-   [ ] For any operator `@` while infering 
-   [ ] For any & each operators also while matching 
-   [ ] Other MFINAE type matching or even some concept like syntax 
-   [ ] pairs 
-   [ ] Derive Clause from Pair and namespace from sequence
-   [ ] dicts 
-   [ ] dict access with `[]`
-   [ ] dict access with `.`
- [ ] Native functions
-    [ ] Add native cast functions (id, int, float, str, list, set, dict)
-    [ ] Add native collections functions (size, empty)
-    [ ] Add native collection casts
-    [ ] print
-    [ ] trace 
- [ ] Custom functions
-    [ ] Import of custom native functions (eg math)
-    [ ] string functions 
-    [ ] file functions 
-    [ ] json parsing & dumping 

